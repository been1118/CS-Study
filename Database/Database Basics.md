# 데이터베이스의 기본

<hr>

데이터베이스 (DB, DataBase): 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음

DBMS (DataBase Management System) : 데이터베이스를 제어, 관리하는 통합 시스템

![image](https://github.com/been1118/CS-Study/assets/123082067/31d349c1-ed08-4f97-a8e3-5e9a480199c7)

## 엔터티(Entity)

<hr>

사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사

### 약한 엔터티와 강한 엔터티

서로 다른 엔터티가 존재할 때, 다른 엔터티의 존재 여부에 따라 종속적이라면, 약한 엔터티, 반대의 경우는 강한 엔터티라고 한다.

## 릴레이션

<hr>

데이터베이스에서 정보를 구분하여 저장하는 기본 단위

## 테이블과 컬렉션

<hr>

| 종류            | 데이터 | 	릴레이션	 | 데이터베이스 |
|---------------| ----- |-----|--------|
| RDBMS(MySQL)  | 레코드	| 테이블	 | 데이터베이스 |
| NoSQL(MongoDB) | 도큐먼트 | 컬렉션 | 데이터베이스 |

## 속성

<hr>

릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

## 도메인

<hr>

속성들이 가질 수 있는 값의 집합

    예시) 속성 -> 성별 -> 가질 수 있는 값 -> {남, 여} -> 도메인

## 필드와 레코드

<hr>

![image](https://github.com/been1118/CS-Study/assets/123082067/01603fe2-f163-4cb2-9b43-4e5c6f793711)

- 필드(field) : 세로 열(column), 속성
- 레코드(record) : 가로 행(row), 튜플(tuble)

## 필드 타입

<hr>

### 숫자 타입

![image](https://github.com/been1118/CS-Study/assets/123082067/d62bfd70-3982-48b4-abb8-4e6adf20ab72)

### 날짜 타입

- DATE
  - 날짜
  - 1000-01-01 ~ 9999-12-31
  - 3byte

- DATETIME
  - 날짜 및 시간
  - 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
  - 8byte
- TIMESTAMP
  - 날짜 및 시간
  - 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07
  - 4byte

### 문자 타입

- CHAR
  - 고정 길이 문자열이며 길이는 0 ~ 255 사이의 값을 가진다.
  - 레코드를 저장할 때 선언한 길이 값으로 고정해서 저장한다.
  - 유동적이지 않은 길이를 가진 데이터에서 효율적이다.

- VARCHAR
  - 가변 길이 문자열이며 0 ~ 65,535 사이의 값을 가진다.
  - 입력된 데이터에 따라 용량을 가변시켜 저장한다.
  - 길이 정보를 저장하기 위해 255 이하의 길이는 1byte, 255를 초과하는 길이는 2byte의 추가 공간이 필요하다.
  - 유동적인 길이를 가진 데이터에서 효율적이다.
- TEXT
  - 게시판 본문 등 큰 문자열을 저장할 때 사용한다.
  - BLOB
  - 이미지, 동영상 등 큰 데이터를 저장할 때 사용한다.
- ENUM
  - 열거한 문자열에서 단일 선택만 가능하다.
  - 각각의 enum 값은 index가 할당된다. (1부터 시작하며 0은 빈 문자열 오류 값의 index)
  - 최대 65,535개의 요소를 넣을 수 있다.
- SET
  - 여러 개의 데이터를 선택할 수 있다.
  - 비트 단위의 연산이 가능하다.
  - 최대 64개의 요소를 넣을 수 있다.

## 관계

<hr>

여러 개의 테이블 서로간의 관계를 정의한다.

![image](https://github.com/been1118/CS-Study/assets/123082067/1feb0c65-23fc-496e-a90c-b88a6d37dd63)

- 1:1(One-to-One)
- 1:N(One-to-Many)
- N:M(Many-to-Many)

## 키

<hr>

테이블 간의 관계를 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치이다.

![image](https://github.com/been1118/CS-Study/assets/123082067/5ebc2dfe-7571-4af2-a977-44968fb13cdd)

- 유일성 : 중복된 값이 없는 성질
- 최소성 : 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있는 성질

1. 슈퍼키(Super key) : 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키
2. 후보키(Candidate key) : 기본키가 될 수 있는 후보들이며, 유일성과 최소성을 동시에 만족하는 키
3. 기본키(Primary Key) : 줄여서 PK 또는 프라이머리키라고도 하며, 유일성과 최소성을 만족하는 키
    - 자연키(Natural key) : 인위적으로 값을 생성하지 않고 기존의 속성에서 선정한 키 -> 언젠가는 변하는 속성이 있음
    - 인조키(Artificial Key) : 인조적으로 생성한 키, 오라클에선 sequence, MySQL에서는 auto increment 등으로 설정한다. -> 자연키와는 대조적으로 변하지 않는다.
4. 대체키(Alternate Key) : 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키
5. 외래키(Foreign Key) : FK라고도 하며, 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는데 사용


## 번외 (SQL Injection)

<hr>

임의의 SQL 문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위.

### 공격 방법

1. 논리적 취약점을 이용한 SQL Injection

sql 쿼리문의 논리적 취약점을 통해 공격하는 방식이다.

ex)
로그인을 할 때 다음과 같은 쿼리문이 나가는 상황에서,
```mysql
SELECT * FROM USER WHERE ID = "abc" AND PASSWORD = "1234";
```

input창에 비밀번호와 이어서 하나의 쿼리문을 추가로 작성하게 되면,

```mysql
1234; DELETE * USER FROM ID = "1";
```

비밀번호가 아이디와 일치해서 True가 되고
뒤에 작성한 DELETE 문도 데이터베이스에 영향을 줄 수도 있게 되는 치명적인 상황이다.

이 밖에도 기본 쿼리문의 WHERE 절에 OR문을 추가하여 '1' = '1'과 같은 true문을 작성하여
무조건 적용되도록 수정한 뒤 DB를 마음대로 조작할 수도 있다.

2. 데이터 노출

시스템에서 발생하는 에러 메시지를 이용해 공격하는 방법이다. 보통 에러는 개발자가 버그를 수정하는 면에서 도움을 받을 수 있는 존재다. 
해커들은 이를 역이용해 악의적인 구문을 삽입하여 에러를 유발시킨다.

즉 예를 들면, 해커는 GET 방식으로 동작하는 URL 쿼리 스트링을 추가하여 에러를 발생시킨다. 
이에 해당하는 오류가 발생하면, 이를 통해 해당 웹앱의 데이터베이스 구조를 유추할 수 있고 해킹에 활용한다.

### 방어 방법

1. input 값을 받을 때, 특수문자 여부 검사하기

> 로그인 전, 검증 로직을 추가하여 미리 설정한 특수문자들이 들어왔을 때 요청을 막아낸다.

2. SQL 서버 오류 발생 시, 해당하는 에러 메시지 감추기

> view를 활용하여 원본 데이터베이스 테이블에는 접근 권한을 높인다. 일반 사용자는 view로만 접근하여 에러를 볼 수 없도록 만든다.

3. Prepared Statement 구문사용

> Prepared Statement를 사용하면, 사용자의 입력 값이 데이터베이스의 파라미터로 들어가기 전에DBMS가 미리 컴파일 하여 실행하지 않고 대기한다.
> 그 후 사용자의 입력 값을 문자열로 인식하게 하여 공격쿼리가 들어간다고 하더라도, 
> 사용자의 입력은 이미 의미 없는 단순 문자열 이기 때문에 전체 쿼리문도 공격자의 의도대로 작동하지 않게 된다.