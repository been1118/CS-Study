# HTTP / 3.0

<hr>

## HTTP / 3.0 등장 배경

<hr>

HTTP는 TCP 기반 위에서 동작되기 때문에, TCP 자체의 핸드쉐이크 과정에서 발생하는 지연 시간과, 
기본적으로 TCP는 패킷이 유실되거나 오류가 있을때 재전송을하는데 이 재전송하는 패킷에 지연이 발생하면 결국 HOL(Head-Of-Line) 블로킹 문제가 발생되었다.

    HOL(Head-Of-Line) 블로킹 이란 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상이다.
    이것 때문에 패킷의 처리 속도는 지연이 되고, 최악의 경우 드랍까지 발생할 수 있다.

HTTP 2.0은 TCP/IP 4 계층의 애플리케이션 계층(L4)에서 HTTP의 HOL(Head-Of-Line) 블로킹 문제를 해결하였지만, 
전송 계층(L3)에서의 TCP HOL(Head-Of-Line) 블로킹 문제를 해결한건 아니기 때문에
TCP로 인터넷 통신을 하는 것이 비효율적인 통신을 하는 것이 되었다.

그러자 IT 기업의 선두주자인 구글은 SPDY 프로토콜에 이어 새로운 UDP 기반인QUIC 프로토콜을 고안하게 된다.
그리고 이 새로운 QUIC 프로토콜이 TCP/IP 4계층에도 동작시키기 위해 설계된 것이 바로 HTTP 3.0 이다.

HTTP/1.1과 HTTP/2는 TCP를 전송에 사용하지만, HTTP/3은 UDP(QUIC)를 사용한다고 보면 된다.

HTTP 3.0은 HTTP 2.0가 가지는 장점들을 모두 가지면서 TCP가 가지는 원초적인 단점을 보완하는데 중점으로 개발되었다. 
그래서 지금까지 거론되었던 HTTP/2 의 문제를 거의 해결하였다고 보면 된다. RTT(Round Trip Time)를 제로 수준으로 줄였고, 
패킷 손실에 대한 빠른 대응, 사용자 IP가 바뀌어도 연결이 유지되는 것이 특징이다.

## QUIC 프로토콜

<hr>

HTTP/3의 가장 큰 특징은 기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 QUIC(Quick UDP Internet Connections)을
사용하여 통신하는 프로토콜이라는 점이다.

### QUIC의 계층 위치

![image](https://github.com/been1118/CS-Study/assets/123082067/9cc1282d-bb14-4628-854e-153ad3a9b2ff)

위의 TCP/IP 4 계층에서 볼 수 있듯이 HTTP/3은 계층 형태는 약간 특이하다.
왜냐하면 QUIC은 TCP + TSL + HTTP의 기능을 모두 구현한 프로토콜이기 때문이다. 
TCP의 프로토콜의 무결성 보장 알고리즘과 SSL이 이식됨으로써 높은 성능과 동시에 신뢰성을 충족시켰다고 보면 된다. 
그래서 계층 위치도 약간 비스듬하게 걸쳐 있게 표현된 것이다.

쉽게 말하자면, Application 계층의 HTTP/3은 QUIC를 동작시키기 위해 있는 것이라고 보면 되고, 
위에서 배웠다시피 QUIC는 UDP 기반으로 만들어졌기에 Transport 계층의 UDP 위에서 동작한다고 보면된다.

## UDP는 신뢰성이 없는게 아니라 탑재를 안했을 뿐이다.

<hr>

UDP는 User Datagram Protocol이라는 이름에서도 알 수 있듯이 데이터그램 방식을 사용하는 프로토콜이기 때문에
패킷의 목적지만 정해져있다면 중간 경로는 신경쓰지 않기 때문에 핸드쉐이크 과정이 필요없다.

결론으로는 UDP는 TCP가 신뢰성을 얻기 위해 내제된 과정을 거치지 않기 때문에 속도가 더 빠를 수 밖에 없다는 것인데,
그렇다면 UDP를 사용하게되면 빠르지만 신뢰성과 패킷의 무결성을 보증할 없다는 뜻인데 이것을 인터넷 통신에 사용해도 문제가 없는 걸까?

이부분은 오해인것이, UDP는 신뢰성이 없는게 아니라 탑재를 안했을 뿐이다.
UDP의 진짜 장점은 커스터마이징이 가능하다는 점이다.

즉, 아래 사진과 같이 UDP 자체는 헤더에 들은게 없어 신뢰성이 낮고 제어 기능도 없지만, 
이후 개발자가 애플리케이션에서 구현을 어떻게 하냐에 따라서 TCP와 비슷한 수준의 기능을 가질 수도 있다는 말이다.

![image](https://github.com/been1118/CS-Study/assets/123082067/a7b8cd8a-ed6d-4bfb-ad59-e50d8489975c)

### 아예 다른 프로토콜은 안되는거야?

사용자와 서버 사이에 있는 TCP와 UDP만 허용하는 방화벽, NAT, 라우터 등의 설정에 따라 차단 될 수 있기 때문에 
프로토콜을 새로 배포하거나 기존에 있던 SCTP 프로토콜을 사용하는 것이 그렇게 녹록치만은 않다.

이를 프로토콜 고착화(ossification)라고 부른다.

게다가 네트워크 스택의 전송 프로토콜 계층에서 뭔가를 바꾼다는 것은 새로운 운영체제 커널을 갱신하고
프로토콜을 구현해 배포하는 것은 상당한 노력이 필요한 과정이다. 
그래서 이미 표준화된 수많은 TCP 개선사항도 광범위하게 지원되지 않아서 널리 배포되거나 사용되지 않고 있는 것이다.

## HTTP / 3.0 장점

<hr>

### 연결 시 레이턴시 감소

기존 TLS+TCP에서는 TLS 연결을 위한 핸드쉐이크와 TCP를 위한 핸드쉐이크가 각각 발생했다.
그래서 TCP는 연결을 생성하기 위해 기본적으로 1 RTT 가 필요하고, 
여기에 TLS를 이용한 암호화 통신까지 한다면 총 3 RTT가 필요하게 된다.

    RTT (Round Trip Time)RTT(Round Trip Time)란, 요청(SYN)을 보낼 때부터 요청에 대한 응답(SYN+ACK)을 받을 때까지의 왕복 시간을 의미한다.

QUIC에서는 이를 한단계로 줄였다.

UDP 위에서 동작하는 QUIC는 통신을 시작할 때 3 Way Handshake 과정을 거치지 않아도 되기 때문에 첫 연결 설정에 1 RTT만 소요된다. 
그 이유는 연결 설정에 필요한 정보와 함께 데이터도 보내버리기 때문이다.
QUIC 내에 아예 TLS 인증서를 내포하고 있기 때문에, 최초의 연결 설정에서 필요한 인증 정보와 데이터를 함께 전송한다. 
그래서 클라이언트가 서버에 어떤 신호를 한번 주고, 서버도 거기에 응답하기만 하면 바로 본 통신을 시작할 수 있다는 것이다

![image](https://github.com/been1118/CS-Study/assets/123082067/d66fc0ae-251a-4022-b525-064e0fb8e715)

위의 그림에서 볼 수 있듯이 TCP+TLS는 서로 자신의 세션 키를 주고 받아 암호화된 연결을 성립하는 
과정을 거치고 나서야 세션 키와 함께 데이터를 교환하기 때문에 핸드쉐이크 과정이 여러번 발생하게 된다.
하지만 QUIC은 서로의 세션 키를 교환하기도 전에 데이터를 교환할 수 있기 때문에 연결 설정이 더 빠르다.
다만, 최초의 요청을 보낼 때는 클라이언트는 서버의 세션 키를 모르는 상태이기 때문에,
목적지인 서버의 Connection ID를 사용하여 생성한 특별한 키인 초기화 키(Initial Key)를 사용하여 통신을 암호화 한다.

그리고 한번 연결에 성공했다면 서버는 그 설정을 캐싱해놓고 있다가, 
다음 연결 때 캐시를 불러와 바로 연결을 하기 때문에 추가적인 핸드 쉐이크 없이 0 RTT만으로 바로 통신을 시작할 수도 있다는 장점도 있다.

![image](https://github.com/been1118/CS-Study/assets/123082067/8a318b94-781c-4bfd-b1a3-338b7949379e)

### 잔존하던 HOLB 현상을 해결

기존 HTTP/1.1 같은 경우 파이프라인(pipeline) 기술을 통해 병렬적으로 리소스를 빠르게 얻도록 하려고 하였지만, 
만일 첫번째 요청에 딜레이가 생기면 나머지 요청이 빨리 처리됬음에도 불구하고 딜레이가 되는 심각한 현상이 있었다.

예를들어 3개의 이미지 a.png, b.png, c.png 를 받는다고 가정한다면 다음과 같이 첫번째 a.png 를 받는 과정에서 오래걸리게 된다면
b와 c 이미지가 아무리 빨리 처리되더라도 결과적으로 늦게 받게 되게 된다.

![image](https://github.com/been1118/CS-Study/assets/123082067/bdb43dc5-3e8a-4e57-8d2e-90b9b86f3e3b)

그래서 이를 극복하기 위해 HTTP/2 에서는 리소스들을 하나의 커넥션에서 병렬적으로 보내도록 개선하였다. 
따라서 a.png 가 시간이 걸리더라도 b 와 c 이미지는 먼저 받아서 보여줄 수 있었다.

![image](https://github.com/been1118/CS-Study/assets/123082067/d422a29d-eb3f-41b2-b2df-2253993b8a4f)

이처럼 HTTP 레이어의 HOL Blocking 은 해결됬지만, 문제는 TCP 레이어의 HOL Blocking 문제가 여전히 잔존해 있었던 것이다.
HTTP/2를 사용하는 일반적인 브라우저는 TCP 연결 한개로 수십, 수백 개의 스트림 데이터를 병렬 전송을 한다. 
그런데 만일 두 엔드포인트 사이 네트워크 어딘가에서 하나의 패킷이 빠지거나 없어진다면, 
없어진 패킷을 다시 전송하고 목적지를 찾는 동안 전체 TCP 연결이 중단되게 된다.

즉, HTTP/2에서 스트림에서 여러가지 프레임들이 뒤 섞여 이동되게 되는데, 
만일 어느 하나의 프레임에 문제가 생기면 상관없는 그 뒤의 프레임까지 영향이 가게 된다. 
따라서 결국은 HTTP의 HOLB처럼 스트림 내 패킷들은 전체가 지연이 되게 된다.

#### 독립 스트림으로 HOLB 단축

그래서 TCP를 버려버리고 새로 QUIC 프로토콜로 구축해서 아예 스트림 자체를 독립적으로 여러개로 나누어서 처리하도록 하였다. 
이를 독립 스트림이라고 한다.

### 패킷 손실 감지에 걸리는 시간 단축

HOLB 해결에 이어 QUIC는 흐름 제어하는 시간까지 단축하였다.
QUIC도 TCP와 마찬가지로 전송하는 패킷에 대한 흐름 제어를 해야한다. QUIC는 기본적으로 TCP와 유사한 방법으로 패킷 손실을 탐지하지만 여기에 몇 가지 알고리즘 개선 사항을 추가하였다.

예를들어 HTTP 2.0에서는 아래 그림과 같이 하나의 스트림에 A, B, C 패킷 프레임들이 비순서대로 전달될때, 만일 세번째 프레임에서 패킷 손실이 일어나면,
패킷 B만 중지되어야 하지만 위에서 배운바와 같이 전혀 연관없는 패킷 A와 C도 모두 막혀 대기를 해야된다.

![image](https://github.com/been1118/CS-Study/assets/123082067/07ffacab-88af-44f1-9fd7-3b5282eadaa6)

이러한 문제를 해결하기 위해 QUIC는 헤더에 패킷의 전송 순서를 나타내는 별도의 패킷 번호 공간을 부여했다.

이를 이용해 QUIC는 패킷 번호를 파악해 개별 파일을 구분하여 중간에 패킷 로스가 발생해도 해당 파일의 스트림만 정지가 되도록 할 수 있다.
하나의 스트림에서 문제가 발생한다고 해도 다른 스트림은 지킬 수 있게 되어 이런 문제에서 자유로워 졌다.

![image](https://github.com/been1118/CS-Study/assets/123082067/46d1561a-31e2-46e9-93ef-a0cbd02b1260)

### 더욱 향상된 멀티플렉싱

HTTP/3도 당연히 HTTP/2와 같은 멀티플렉싱을 지원한다.
그리고 독립 스트림 방식으로 기존의 멀티플렉싱을 더욱 강화시켰다고 보면 된다.

### 보안을 더욱 강화

HTTP/3와 그 기반 기술인 QUIC은 TLS 암호화를 기본적으로 사용한다.
물론 UDP와 TLS가 결합된 기술로는 DTLS라는 기술도 있지만 'TCP의 재구현'이 목표 중 하나인 QUIC와는 지향하는 바가 다르다.
이처럼 기본적으로 QUIC 내에 TLS이 포함되어있기 때문에 TCP와 달리 헤더 영역도 같이 암호화된다.

### 네트워크가 변경 되도 연결이 유지

TCP의 경우 클라이언트와 서버가 서로를 구분하기 위해서는 클라이언트 IP, 클라이언트 PORT, 서버 IP, 서버 PORT, 이렇게 네 가지가 필요하다. 
그래서 클라이언트의 IP가 바뀌는 상황이 발생하면 연결이 끊어져 버린다.

QUIC은 Connection ID를 사용하여 서버와 연결을 생성한다.
Connction ID는 각 연결은 연결 식별자나 연결 ID를 가지므로 이를 통해 연결을 식별한다.

Connection ID는 랜덤한 값일 뿐, 클라이언트의 IP와는 전혀 무관한 데이터이기 때문에 클라이언트의 IP가 변경되더라도 기존의 연결을 계속 유지할 수 있다.
그래서 새로 연결을 생성할 때 거쳐야하는 핸드쉐이크 과정을 생략할 수 있다.

따라서 휴대폰으로 인터넷을 할 때, 중간에 와이파이에서 LTE로 변경해도 스트림이 계속 유지가 된다.

하지만 똑같은 Connection ID만 사용한다면 해커가 네트워크를 통해 사용자를 추적하여 보안 문제가 일어날 수도 있을 것이다. 
그래서 QUIC는 새 네트워크가 사용될 때마다 Connection ID를 변경한다.

위의 말과 행동이 다르겠다고 생각하겠지만, 내부적으로 클라이언트와 서버가 모두 연결을 위해 무작위로 생성한 Connection ID에 대해 인지하고 있고, 
네트워크가 바뀔때 Connection ID를 바꾸더라도 이게 이전 Connectin ID와 동일하다고 인지하여 연결을 유지하는 것이다.

## HTTP / 3.0 단점?

<hr>

HTTP 3.0 과 QUIC 프로토콜이 이렇게 좋은 많은 것들을 제공해 주고 있지만, 
아직 전세계의 기업들이 이를 막상 도입하지 않는 현실적인 이유가 존재한다.

### 기존 체계 호환성 문제

HTTP/1.1 이나 HTTP/2 기반의 프론트엔드단 최적화를 이미 적용한 기업의 경우 QUIC 도입에 부담스러울 수 있다.

### 암호화로 네트워크 제어가 힘듬

QUIC는 기존에는 암호화하지 않던 헤더 필드도 암호화한다.
그래서 이런 헤더의 정보를 사용하는 ISP나 네트워크 중계회사들은 기존에 암호화하지 않던 헤더 필드 영역들을 읽을 수 없어 네트워크 혼잡을 관리하기 위한 네트워크를 최적화하기 힘들다.

### 암호화로 리소스가 많이 듬

QUIC은 패킷별로 암호화를 한다.
이는 기존의 TLS-TCP에서 패킷을 묶어서 암호화하는 것보다 더 큰 리소스 소모를 불러올 수 있다는 단점이 있다.

### QUIC는 CPU를 너무 사용함

QUIC은 너무 많은 CPU 시간을 차지한다.
따라서 보급형 스마트폰과 IoT 장치같은 마이크로 애플리케이션들은 이용에 어려움을 겪을 수도 있다.

물론 시간이 지나면 개선될수도 있다. 
다만 문제는 추가적인 CPU 사용이 배포자에게 얼마나 영향을 끼치는가 이다.

### UDP의 보안적인 문제

DNS에서 TCP나 UDP를 53포트를 이용해 통신하게 되는데, 
53 포트가 아닌 UDP 트래픽이 최근에는 도스 공격에 주로 사용되기 때문에 많은 서비스들에서 차단하거나 속도를 제한하고 있다.

그래서 QUIC에서는 초기 패킷이 최소 1200바이트여야 한다는 조건과 서버가 클라이언트로부터 응답 패킷을 받지 않으면
요청 크기의 3배 이상은 절대 보내면 안 된다는 프로토콜의 제약사항으로 이를 해결하려고 노력중이라고 한다.

## 정리

<hr>

HTTP / 3.0은 기존의 HTTP의 고질적인 문제인 TCP의 HOLB을 해결하기 위해 UDP를 사용한 QUIC을 사용한다.
아직 많이 사용되고 있지는 않지만, 여러 장점이 있고 단점은 보완될 여지가 많이 있다.


